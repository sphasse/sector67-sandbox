'''
A script to convert GCode to Anilam conversational format.

Copyright (C) 2010 Scott Hasse <scott.hasse@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.


Developed by Scott Hasse for use at http://sector67.org

More details on the gcode specification can be found here:

http://www.linuxcnc.org/handbook/gcode/g-code.html

and

http://linuxcnc.org/docs/html/gcode_overview.html

The conversational format can be found partially described at:

http://www.anilam.com/pdf/6000iUsersManual.pdf

and

http://www.anilam.com/Uploads/File/CNC%20Control%20Manuals%20September%202006/3000M/70000504H.pdf

In general since the code generated by this script will ultimately be used to move
a machine, the goal of this script is to accurately translate programs, and
to fail fast and accurately when that cannot be done.  As a result, some of the 
implementation (most notably convert_to_conversational) probably appears to
be implemented in a fairly brittle manner.  This is for the most part intentional.
Each command and variation handled is explicit, and other unknown commands result
in an error.

It is expected this script will have a few primary uses:

1) For converting programs that are larger than the Anilam 1100 can handle.  These
programs will then subsequently be drip fed to the mill.
2) To correctly translate gcode programs that use arcs with IJK coordinates
specified incrementally.  Although incremental IJK specification is the default
in gcode, the Anilam-based translator expects the IJK to be absolute.  Although
this translator is incomplete, it is superior in that respect.
3) To avoid multiple round-trips to the mill with floppy disks.

TODO:
* The gcode verifier could be greatly improved.  However, since the translation
is done rather explicitly, it is hoped this will not introduce any risk to the
translation process.
* Translations for some Anilam functions that have gcode equivalents:

peck drill
tool change

etc. are not implemented
'''

import re
import getopt
import sys
from datetime import datetime

known_gcode_words = "FGIJKMNOPRSTXYZ"
log_level = 1
current_coords_mode = "ABS"
current_arc_coords_mode = "INC"

motion_modal_commands = frozenset(["G0", "G1", "G2", "G3", "G80", "G81", "G82", "G83", "G84", "G85", "G86", "G87", "G88", "G89"])
plane_selection_modal_commands = frozenset(["G17", "G18", "G19"])
distance_modal_commands = frozenset(["G90", "G91"])
spindle_speed_modal_commands = frozenset(["G93", "G94"])
units_modal_commands = frozenset(["G20", "G21"])
cutter_diameter_compensation_modal_commands = frozenset(["G40", "G41", "G42"])
tool_length_offset_modal_commands  = frozenset(["G43", "G49"])
return_mode_in_canned_cycles_modal_commands = frozenset(["G98", "G99"])
coordinate_system_selection_modal_commands = frozenset(["G54", "G55", "G56", "G57", "G58", "G59", "G59.1", "G59.2", "G59.3"])

g_modal_groups = [motion_modal_commands, plane_selection_modal_commands, distance_modal_commands, spindle_speed_modal_commands, units_modal_commands, cutter_diameter_compensation_modal_commands, tool_length_offset_modal_commands, return_mode_in_canned_cycles_modal_commands, coordinate_system_selection_modal_commands]

axis_clamping_modal_commands = frozenset(["M26", "M27"]) 
stopping_modal_commands = frozenset(["M0", "M1", "M2", "M30", "M60"])
tool_change_modal_commands  = frozenset(["M6"])
spindle_turning_modal_commands  = frozenset(["M3", "M4", "M5"])
coolant_modal_commands = frozenset(["M7", "M8", "M9"])
feed_and_speed_override_bypass_modal_commands = frozenset(["M48", "M49"])

m_modal_groups = [axis_clamping_modal_commands, stopping_modal_commands, tool_change_modal_commands, spindle_turning_modal_commands, coolant_modal_commands, feed_and_speed_override_bypass_modal_commands]

non_modal_commands = frozenset(["G4", "G10", "G28", "G30", "G53", "G92", "G92.1", "G92.2", "G92.3"])

def error(message):
    print("ERROR: " + message)

def debug(message):
    if (log_level < 1):
        print("DEBUG: " + message)


def main():
    global log_level
    
    debug("raw arguments")
    debug(sys.argv[1:])
    if (len(sys.argv) == 1):
        usage()
        sys.exit(2)
    try:
        opts, args = getopt.getopt(sys.argv[1:], "ho:i:dg:", ["help", "output=", "input=","debug", "ignore="])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    output_file = None
    input_file = None
    ignore_regex = None
    for o, a in opts:
        if o in ("-d", "--debug"):
            log_level = 0
        elif o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-g", "--ignore"):
            ignore_regex = a
        elif o in ("-i", "--input"):
            input_file = a
        elif o in ("-o", "--output"):
            output_file = a
        else:
            assert False, "unhandled option"
    
    if (input_file == None or output_file == None):
        print("You must supply both an input file and an output file")
        sys.exit(2)
    translate_file(input_file, output_file, ignore_regex)

def usage():
    print """
    A command-line program to convert gcode files into Anilam 
    conversational format.
    Usage:
    anilampost.py --input=<input_file_name> --output=<output_file_name> [--debug] [--ignore=regex]
    
    Examples:
    anilampost.py --input=TEST.G --output=TEST.M
    
    If the debug option is specified, the original gcode is written out as comments
    in-line with the converted code.
    
    If you wish to ignore specific words, you can specify an --ignore with a corresponding regex.
    The regex is applied to the normalized form of each parsed gcode word to determine if it should 
    be ignored or not.
    
    This is used to eliminate gcode words that cannot be accurately translated into conversational form,
    but this should only be used to remove words that do not have an adverse effect on the actual
    milling process.  For instance the sector 67 mill does not have spindle control or automated tool
    change capability, so even though some programs generate those sorts of commands, we ignore them
    during the conversion process.
    
    Some examples of --ignore regular expressions would be:
    
    --ignore="^(M3|G54)$"
    
    """


"""
translate an entire file line-by-line
"""
def translate_file(input_filename, output_filename, ignore_regex=None):
    debug("parsing " + input_filename)
    input_file = open(input_filename, "r")
    debug("sending output to " + output_filename)
    output_file = open(output_filename, "w")
    line_num = 0
    output_file.write("* Anilam conversational format generated by anilampost.py at " + str(datetime.now()) + "\n")
    output_file.write("* original file: " + input_filename + "\n")
    output_file.write("\n")
    for line in input_file:
        line_num += 1
        debug("Processing line number: " + str(line_num))
        debug(line)
        result = process_line(line, line_num, ignore_regex)
        output_file.write(result)
            
    input_file.close()
    output_file.close()


"""
process an individual line as a string
returns the conversational code as a string
"""
def process_line(line, line_num=-1, ignore_regex=None):
    result = ""
    line_without_comments = re.sub("\\(.*?\\)", "", line)
    if (re.match("^\s*$", line)):
        debug("Processing as a line with only whitespace")
        result = "\n"
    elif (re.match("^\s*%\s*$", line_without_comments)):
        debug("Processing as a standalone % designating program start or end")
        result = "* %\n"
    elif (re.match("^;", line)):
        #The line starts with a semicolon, it is a comment
        debug("Processing as a comment line")
        result = result + "* " + line
    elif (re.match("^\s*$", line_without_comments)):
        #The line is comments and white space only
        #Extract the comments and print them
        debug("Processing as a line with comments and whitespace only")
        comments = extract_comments(line)
        for comment in comments:
            result = result + "* " + comment + "\n"
    else:
        #The block is gcode and might contain comments
        debug("Processing as a line with gcode and optionally comments")
        #First, extract in-line comments
        if (log_level < 1):
            # in debug mode, write the original line in-line
            result = result + "* " + line
        comments = extract_comments(line)
        for comment in comments:
            result = result + "* inline comment: " + comment + "\n"
            
        block = parse_gcode(line, line_num)

        post_ignore_block = []
        for word in block:
            if ((ignore_regex != None) and (re.match(ignore_regex, word) != None)):
	        debug("Ignoring the line as it matched the ignore_regex: " + ignore_regex)
                result = result + "* per --ignore regex, ignored word: " + word + "\n"
	    else:
	        post_ignore_block.append(word)

        verify_gcode(post_ignore_block, line_num)
        
        #might need to multiplex one line of commands into multiple lines
        multiplexed_blocks = multiplex_blocks(post_ignore_block)
        for multiplexed_block in multiplexed_blocks:
            #Then, convert each block
            conversational = convert_to_conversational(multiplexed_block, line, line_num)
            result = result + conversational + "\n"
        
    return result
    

'''
Given a block of gcode, returns an array of comments in that block 
'''
def extract_comments(block):
    #strip out inline comments, non-greedy
    result = re.findall("\\((.*?)\\)", block)
    return result


"""
A method to return the count of a certain type of code words in a block.
This is used to validate the gcode
block_array is an array of gcode words as strings
command is a letter

"""
def count_words(block_array, command):
    word_count = 0
    for word in block_array:
        if (word.startswith(command)):
            word_count = word_count + 1
    return word_count

"""
A method to parse a line (block) of gcode passed as a string into individual words
returns an array of individual gcode words as strings
This method cleans up the gcode in significant ways:
1) comments are stripped
2) whitespace is stripped
3) leading slashes are stripped
4) all letters are capitalized
5) extraneous leading zeros are stripped

"""
def parse_gcode(block, linenum=-1):
    #strip optional leading "/"
    block = re.sub("^/", "", block)
    #strip out all whitespace
    block = re.sub("\s","", block)
    #strip out inline comments, non-greedy
    block = re.sub("\\(.*?\\)", "", block)
    #capitalize all letters
    block = block.upper()
    
    #parse the block into individual words, failing fast if we encounter any unknown gcode words
        
    result = re.findall("[" + known_gcode_words + "][+-]?\d*\.?\d*", block)
    #check that each part of the string was matched, if not, raise an exception
    test_result = ""
    for word in result:
        test_result += word
    if (test_result != block):
        error("I was not able to parse a block of gcode.  When separating the following block using regex:")
        error(block)
        error("I got the following result:")
        error(test_result)
        raise Exception("I was not able to successfully parse the [" + block + "] block of gcode (input file line number: " + str(linenum) + ").")
    
    # strip leading zeros from the result
    # drop N words
    stripped_result = []
    for word in result:
        command = command_part(word)
        if (command not in "N"):
            real = real_part(word)
            stripped_result.append(command + real)
    
    return stripped_result


'''
Check for duplicate words from the same modal group
In order to perform efficient set comparison, this method expects that the 
block_array will contain words with commands that have already had extraneous 
leading zeros stripped.  It does, however, check to make sure it has checked
all of the commands for the passed in command letter.  If they have not all
been checked for duplicates (that is, a command did not exist anywhere in any of
the sets in the modal_groups list, it should log an error that all gcode words
could not be checked.

commands from the non_modal_commands are subtracted from the set

block_array is an array of strings containing the individual gcode words
modal_groups is a list of sets of the modal groups commands
command is a single letter prefix of gcode commands (typically, "G" or "M")
'''
def check_for_duplicates(block_array, modal_groups, command, linenum=-1):
    #First, subtract out any non-modal words
    modal_words = set(block_array).difference(non_modal_commands)
    #get a set of words to check
    leftover_words = set()
    for word in block_array:
        if (word.startswith(command) and word in modal_words):
            leftover_words.add(word)
    for modal_group in modal_groups:
        intersection = len(modal_group.intersection(modal_words))
        leftover_words = leftover_words.difference(modal_group)
        # ensure each word is accounted for in the checks
        if (intersection > 1):
            error ("There is more than one " + command + " word from the same modal group on input file line " + str(linenum) + ".  The input gcode is not valid.")
            error ("The modal group is: " + str(modal_group))
            error ("The line is: " + str(block_array))
            error ("The line number is: " + str(linenum))

            raise Exception("There is more than one " + command + " word from the same modal group.  The input gcode is not valid.")
    if (len(leftover_words) != 0):
        error ("Not all modal " + command + " words were able to be recognized.  The unrecognized commands were: " + str(leftover_words) + " on line " + str(linenum))
        error ("The line is: " + str(block_array))
        error ("The line number is: " + str(linenum))
        raise Exception("Not all modal " + command + " words were able to be recognized, some were missed.  The missed commands were: " + str(leftover_words) + " on line " + str(linenum))


"""
Verify that the input gcode is valid.
Currently does some checks, but could do more.
"""
def verify_gcode(block_array, linenum=-1):
    # TODO: N words only in the first position
    # TODO: Check for line too long? 256 character limit
    
    # It is an error to put a G-code from group 1 (move) and a G-code from group 0 (non-modal) 
    # on the same line if both of them use axis words. If an axis word-using G-code from group 1 is 
    # implicitly in effect on a line (by having been activated on an earlier line), and a group 0 G-code 
    # that uses axis words appears on the line, the activity of the group 1 G-code is suspended for that 
    # line. The axis word-using G-codes from group 0 are G10, G28, G30, and G92. 
    axis_using_words = motion_modal_commands.union(frozenset(["G10", "G28", "G30", "G92"]))
    intersection = axis_using_words.intersection(set(block_array))
    if (len(intersection) > 1):
        error("There were more than 1 axis-using words in a block.  The input gcode is invalid.")
	error("Line number: " + str(linenum))
	error("Block: " + str(block_array))
	raise Exception("There were more than 1 axis-using G words in a block.  The input gcode is invalid")

    # A line may have any number of G words.
    # A line may have zero to four M words.
    # For all other legal letters, a line may have only one word beginning with that letter.    
    for letter in known_gcode_words:
        word_count = count_words(block_array, letter)
        limit = 1
        if (letter in "M"):
            limit = 4
        elif (letter in "G"):
            limit = len(g_modal_groups)
        if (word_count > limit):
            error("There were more than " + str(limit) + " " + letter + " words in a block.  The input gcode is invalid.")
            error("Line number: " + str(linenum))
            error("Block: " + str(block_array))
            raise Exception("There were more " + str(limit) + " " + letter + " words in a block.  The input gcode is invalid")
            

    # Two M words from the same modal group may not appear on the same line.
    
    check_for_duplicates(block_array, m_modal_groups, "M", linenum)

    # Two G words from the same modal group may not appear on the same line.
    check_for_duplicates(block_array, g_modal_groups, "G", linenum)
    

"""
Given a gcode word as a string, returns the command part of it
"""
def command_part(word):
    command_part = word[0]
    if (re.match("[" + known_gcode_words + "]",command_part)) :
        return command_part
    else:
        raise Exception("Unknown gcode command part: " + command_part + " in word [" + word + "]")

"""
Given a gcode word as a string, returns the real_number part of it
extraneous leading zeros are stripped
"""
def real_part(word):
    real_part = word[1:]
    stripped_real_part = re.sub("^([-+]?)0*(.+)$", "\\1\\2", real_part)
    try:
        float(stripped_real_part)
        return stripped_real_part
    except ValueError:
        raise Exception("Uknown gcode real part: " + real_part + " in word [" + word + "]")

def to_four_digits(real):
    number = float(real)
    result = "%.4f" % number 
    return result

"""
Splits a single block containing mutliple commands into  individual blocks suitable for converting into 
conversational format.  This is a somewhat hard problem given the possible combinations of parameters, so
this method takes a conservative approach and checks at the end to make sure no coordiantes are left over.  Bare XYZ
lines are lumped into the perform motion step.

it expects an array of gcode words representing one block and returns array of array of gcode words representing blocks

The order of execution of items on a line is defined not by the position of each item on the line, but by the following list:

   1. Comment (including message)
   2. Set feed rate mode (G93, G94).
   3. Set feed rate (F).
   4. Set spindle speed (S).
   5. Select tool (T).
   6. Change tool (M6).
   7. Spindle on or off (M3, M4, M5).
   8. Coolant on or off (M7, M8, M9).
   9. Enable or disable overrides (M48, M49).
  10. Dwell (G4).
  11. Set active plane (G17, G18, G19).
  12. Set length units (G20, G21).
  13. Cutter radius compensation on or off (G40, G41, G42)
  14. Cutter length compensation on or off (G43, G49)
  15. Coordinate system selection (G54, G55, G56, G57, G58, G59, G59.1, G59.2, G59.3).
  16. Set path control mode (G61, G61.1, G64)
  17. Set distance mode (G90, G91).
  18. Set retract mode (G98, G99).
  19. Go to reference location (G28, G30) or change coordinate system data (G10) or set axis offsets (G92, G92.1, G92.2, G94).
  20. Perform motion (G0 to G3, G33, G73, G76, G80 to G89), as modified (possibly) by G53.
  21. Stop (M0, M1, M2, M30, M60).
  
"""
def multiplex_blocks(block_array):
    blocks = []
    full_command_set = set(block_array)
    # make a dictionary of commands and command words
    
    commands = {}
        
    command_string = ""
    for word in block_array:
        # use a set to determine what the remaining commands are
        command_string = command_string + command_part(word)      
        # also make a map of the remaining commands to allow easy string formatting
        commands[command_part(word)] = real_part(word)
            
    command_word_set = set(command_string)
    
    step_2_commands = set(["G93", "G94"])
    step_3_commands = set(["F"])
    step_4_commands = set(["S"])
    step_5_commands = set(["T"])
    step_6_commands = set(["M6"])
    step_7_commands = set(["M3", "M4", "M5"])
    step_8_commands = set(["M7", "M8", "M9"])
    step_9_commands = set(["M48", "M49"])
    step_10_commands = set(["G4"])
    step_11_commands = set(["G17", "G18", "G19"])
    step_12_commands = set(["G20", "G21"])
    step_13_commands = set(["G40", "G41", "G42"])
    step_14_commands = set(["G43", "G49"])
    step_15_commands = set(["G54", "G55", "G56", "G57", "G58", "G59", "G59.1", "G59.2", "G59.3"])
    step_16_commands = set(["G61", "G61.1", "G64"])
    step_17_commands = set(["G90", "G91"])
    step_18_commands = set(["G98", "G99"])
    step_19_commands = set(["G28", "G30", "G10", "G92", "G92.1", "G92.2"])
    step_20_commands = set(["G0", "G1", "G2", "G3", "G33", "G73", "G76", "G80", "G81", "G82", "G83", "G84", "G85", "G86", "G87", "G88", "G89"])
    step_21_commands = set(["M0", "M1", "M2", "M30", "M60"])
    
    if (len(step_2_commands.intersection(full_command_set)) == 1):
        command = step_2_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_2_commands)
    if ("F" in command_word_set):
        command = "F" + commands["F"]
        blocks.append([command])
        full_command_set.remove(command)
    if ("S" in command_word_set):
        command = "S" + commands["S"]
        blocks.append([command])
        full_command_set.remove(command)
    if ("T" in command_word_set):
        command = "T" + commands["T"]
        blocks.append([command])
        full_command_set.remove(command)
    if ("M6" in full_command_set):
        command = "M6"
        blocks.append([command])
        full_command_set.remove(command)
    if (len(step_7_commands.intersection(full_command_set)) == 1):
        command = step_7_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_7_commands)
    if (len(step_8_commands.intersection(full_command_set)) == 1):
        command = step_8_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_8_commands)
    if (len(step_9_commands.intersection(full_command_set)) == 1):
        command = step_9_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_9_commands)
    if ("G4" in full_command_set):
        # dwell requires a P
        command = "G4"
        p_command = "P" + commands["P"]
        blocks.append([command, p_command])
        full_command_set.remove(command)
        full_command_set.remove(p_command)
    if (len(step_11_commands.intersection(full_command_set)) == 1):
        command = step_11_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_11_commands)
    if (len(step_12_commands.intersection(full_command_set)) == 1):
        command = step_12_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_12_commands)
    if (len(step_13_commands.intersection(full_command_set)) == 1):
        command = step_13_commands.intersection(full_command_set).pop()
        if (command in set(["G41", "G42"])):
            d_command = "D" + commands["D"]
            blocks.append([command, d_command])
            full_command_set.remove(d_command)                    
        else:
            blocks.append([command])
        full_command_set.remove(command)
    if (len(step_14_commands.intersection(full_command_set)) == 1):
        command = step_14_commands.intersection(full_command_set).pop()
        if (command in set(["G43"])):
            h_command = "H" + commands["H"]
            blocks.append([command, h_command])
            full_command_set.remove(h_command)                    
        else:
            blocks.append([command])
        full_command_set.remove(command)
    if (len(step_15_commands.intersection(full_command_set)) == 1):
        command = step_15_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_15_commands)        
    if (len(step_16_commands.intersection(full_command_set)) == 1):
        command = step_16_commands.intersection(full_command_set).pop()
        if (command in set(["G64"])):
            p_command = "P" + commands["P"]
            blocks.append([command, p_command])
            full_command_set.remove(p_command)
        else:
            blocks.append([command])
        full_command_set.remove(command)
    if (len(step_17_commands.intersection(full_command_set)) == 1):
        command = step_17_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_17_commands)
    if (len(step_18_commands.intersection(full_command_set)) == 1):
        command = step_18_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_18_commands)
    if (len(step_19_commands.intersection(full_command_set)) == 1):
        command = step_19_commands.intersection(full_command_set).pop()
        if (command in set(["G10"])):
            l_command = "L" + commands["L"]
            if (l_command in set["L1", "L10"]):
                #P Q R X W Z
                #TODO implement
                pass
            elif (l_command in set(["L2", "L20"])):
                #P R X Y Z A B C
                #TODO implement
                pass
            else:
                raise Exception("Unrecognized G10/L## command")
            blocks.append([command, l_command])
            full_command_set.remove(l_command)
        else:
            blocks.append([command])
        full_command_set.remove(command)    
    # start step 20
    result = []
    append = False
    if (len(step_20_commands.intersection(full_command_set)) == 1):
        # for motion, put the motion command first
        append = True
        command = step_20_commands.intersection(full_command_set).pop()
        full_command_set.remove(command)
        result.append(command)
    #step 20 continued, add everything else except the step 21 commands
    temp_list = list(full_command_set)
    temp_list.sort()
    for word in temp_list:
        append = True
        if word not in step_21_commands:
            result.append(word)
            full_command_set.remove(word)
    if (append):
        blocks.append(result)
    if (len(step_21_commands.intersection(full_command_set)) == 1):
        command = step_21_commands.intersection(full_command_set).pop()
        blocks.append([command])
        full_command_set.difference_update(step_21_commands)  
        
    # all commands should be accounted for and removed from the full_command_set.  The full_command_set should now be empty.
    if (len(full_command_set) != 0):
        raise Exception("I was not able to account for all of words during multiplexing.  The leftover words are: " + str(full_command_set))
    
    return blocks

"""
takes a dictionary of command and real values, and creates a string for filling in from 
conversational X/Y/Z/Feed format from the values present
"""
def format_xyzf(commands):
    result = ""
    if ("X" in commands):
        result = result + "X {X:.4f} "
    if ("Y" in commands):
        result = result + "Y {Y:.4f} "
    if ("Z" in commands):
        result = result + "Z {Z:.4f} "
    if ("F" in commands):
        result = result + "Feed {F:.4f} "
    return result.strip()


"""
converts an array of gcode words representing one gcode block
to Anilam conversational commands
"""
def convert_to_conversational(block_array, original_block="UNKNOWN", line_no=-1):
    global current_arc_coords_mode
    result = ""
    # preserve whitespace
    if (len(block_array) == 0):
        return ""
    
    # Currently takes a naive approach to parsing, just look at the first word, and 
    # the subsequent arguments to determine how to translate

    # for use when we need to look up a float value by command
    commands = {}
    
    command_string = ""
    for word in block_array:
        # use a set to determine what the remaining commands are
        command_string = command_string + command_part(word)      
        # also make a map of the remaining commands to allow easy string formatting
        commands[command_part(word)] = float(real_part(word))
        
    command_set = set(command_string)
        
    #determine the command args and format it explicitly
    #error on cases not handled
    #it is expected that extraneous leading zeros have already beens stripped
    if (count_words(block_array, "G") == 1):
        # convert the case of a single G
        debug("Converting G command: " + original_block)
        real = commands["G"]
        del commands["G"]
        command_set.remove("G")
        if (real == 0):
            if (command_set.difference(set("XYZF")) == set("")):
                # if the only commands left are XYZ and F, then process it
                result = ("Rapid      " + format_xyzf(commands) + "").format(**commands)
            else:
                error("unrecognized G0 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G0 command: " + original_block)
        elif (real == 1):
            if (command_set.difference(set("XYZF")) == set("")):
            # if the only commands left are XYZ and F, then process it
                result = ("Line       " + format_xyzf(commands) + "").format(**commands)
            else:
                error("unrecognized G1 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G1 command: " + original_block)
        elif (real == 2):
            if (current_arc_coords_mode == "INC"):
            # convert the incremental coordinates to absolute to match what Anilam expects
                if ("I" in commands):
                    new_i = commands["I"] + commands["X"]
                    commands["I"] = new_i
                if ("J" in commands):
                    new_j = commands["J"] + commands["Y"]
                    commands["J"] = new_j
            if (command_set == set("XYZIJF")):
                result = "Arc Cw     X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f} Feed {F:.4f}".format(**commands)
            elif (command_set == set("XYZIJ")):
                result = "Arc Cw     X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f}".format(**commands)
            else:
                error("unrecognized G2 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G2 command: " + original_block)
        elif (real == 3):
            if (current_arc_coords_mode == "INC"):
            # convert the incremental coordinates to absolute to match what Anilam expects
                if ("I" in commands):
                    new_i = commands["I"] + commands["X"]
                    commands["I"] = new_i
                if ("J" in commands):
                    new_j = commands["J"] + commands["Y"]
                    commands["J"] = new_j
            if (commands == set("XYZIJF")):
                result = "Arc Ccw    X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f} Feed {F:.4f}".format(**commands)
            elif (commands == set("XYZIJ")):
                result = "Arc Ccw    X {X:.4f} Y {Y:.4f} Z {Z:.4f} XCenter {I:.4f} YCenter {J:.4f}".format(**commands)
            else:
                error("unrecognized G3 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G3 command: " + original_block)
        elif (real == 4 and command_set == set("P")):
            #dwell
            result = "Dwell {P:.4f}".format(**commands)
        elif (real == 10 and command_set == set("PRZ")):
            #tool definition
            raise Exception("tool handling not yet implemented")
        elif (real == 17 and command_set == set("")):
            result = "Plane XY"
        elif (real == 18 and command_set == set("")):
            result = "Plane ZX"
        elif (real == 19 and command_set == set("")):
            result = "Plane YZ"
        elif (real == 20 and command_set == set("")):
            result = "Unit INCH"
        elif (real == 21 and command_set == set("")):
            result = "Unit MM"
        elif (real == 80 and command_set == set("")):
            result = "DrillOff"
        elif (real == 81):
            raise Exception("basic drilling needs to be verified before production usage")
            """
            G81 is a basic drilling cycle, generally used for center drilling or hole
	    drilling that does not require a pecking motion. It feeds from the start
	    height (R) to the specified hole depth (Z) at a given feedrate (F), then
            rapids to the return height (P).
            """
            if (command_set == set("ZRF")):
                result = "BasicDrill ZDepth {Z:.4f} StartHgt {R:.4f} Feed {F:.4f}".format(**commands)
            else:
                error("unrecognized G81 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G81 command: " + original_block)
        elif (real == 83):
            raise Exception("peck drilling needs to be verified before production usage")
            """
            G83 is the peck drilling cycle, generally used for peck drilling relatively
	    shallow holes. G83 feeds from the R-plane to the first peck depth
	    (calculated so that all pecks are equal and do not exceed the maximum
	    peck distance programmed in I word). Then rapid retracts to R-plane (to
	    clear chip), rapids down to previous depth less .02", and continues this
	    loop until it reaches the final hole depth. It then rapid retracts to the P
            dimension. Refer to Table 5-3.
            """
            if (command_set == set("ZRIFP")):
                result = "PeckDrill ZDepth {Z:.4f} StartHgt {R:.4f} Peck {I:.4f} Feed {F:.4f} ReturnHeight {P:.4f}".format(**commands)
            else:
                error("unrecognized G81 command on line: " + str(line_no))
                error("original line:")
                error(original_block)
                raise Exception("unrecognized G81 command: " + original_block)            
            
        elif (real == 90 and command_set == set("")):
            #Absolute distance mode
            #The default
            result = "Dim Abs"
        elif (real == 91 and command_set == set("")):
            #Incremental distance mode
            result = "Dim Inc"
        elif (real == 90.1 and command_set == set("")):
            #Arc centers I,J,K are absolute
            #Use this setting to determine how to handle IJK
            current_arc_coords_mode = "ABS"
            result = result
        elif (real == 91.1 and command_set == set("")):
            #The default
            #Arc centers I,J,K are relative to the arc's starting point
            #Use this setting to determine how to handle IJK
            current_arc_coords_mode = "INC"
            result = result
        else:
            error("unrecognized G command on line: " + str(line_no))
            error("original line:")
            error(original_block)
            raise Exception("unrecognized G command: " + original_block)
    elif (count_words(block_array, "M") == 1):
        debug("Converting M command")
        real = commands["M"]
        del commands["M"]
        command_set.remove("M")
        # convert the case of one M command
        if (real == 0 and command_set == set("")):
            #End Program 
            result = "MCode 0"
        elif (real == 2 and command_set == set("")):
            #Turn spindle clockwise
            result = "EndMain"
        elif (real == 3 and command_set == set("")):
            #Turn spindle clockwise
            result = "MCode 3"
        elif (real == 4 and command_set == set("")):
            #Turn spindle counter-clockwise
            result = "MCode 4"
        elif (real == 5 and command_set == set("")):
            #Stop spindle
            result = "MCode 5"
        elif (real == 6 and command_set == set("")):
            #Change tool
            result = "MCode 6"        
        else:
            error("unrecognized M command on line: " + str(line_no))
            error("original line:")
            error(original_block)
            raise Exception("unrecognized M command: " + str(original_block))
    elif (command_set == set("O")):
        result = "* " + block_array[0]
    elif (command_set == set("S")):
        real = commands["S"]
        result = "RPM        {0:.4f}" .format(real)
    elif (command_set == set("T")):
        real = commands["T"]
        result = "Tool# {0:.0f}" .format(real)
    elif (command_set.difference(set("XYZF")) == set("")):
        # convert bare X/Y/Z/F lines
        result = (format_xyzf(commands) + "").format(**commands)
    else:
        error("unrecognized command on line: " + str(line_no))
        error("original line:")
        error(original_block)
        raise Exception("unrecognized command: " + str(original_block))
    return result

# when spawned via command line, execute the main method
if __name__ == "__main__":
    main()